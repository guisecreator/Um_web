package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"errors"
	"fmt"
	"github.com/guisecreator/um_web/graphql/model"
	"github.com/guisecreator/um_web/pkg/authpayload"
	"github.com/uptrace/bun"
	"log"
	"strconv"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context,
	newUser []*model.NewUser) ([]*model.User, error) {
	var users = make([]*model.User, 0)

	for userData, _ := range newUser {
		user := []*model.User{&model.User{
			Login: newUser[userData].Login,
			Role:  newUser[userData].Role,
		}}
		if user != nil {
			_ = fmt.Errorf("user not created: %v", users)
		}

		_, err := r.Db.
			NewInsert().
			Model(&users).
			Returning("*").
			Exec(ctx)
		if err != nil {
			return nil, err
		}

		log.Println("user created")

		users = append(users, user...)
		if users != nil {
			return nil, err
		}

	}

	return users, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context,
	userUpdate []*model.UpdateUser) ([]*model.User, error) {
	var users = make([]*model.User, 0)

	for userData, _ := range userUpdate {
		user := []*model.User{&model.User{
			Login: userUpdate[userData].Login,
			Role:  userUpdate[userData].Role,
		}}
		if user != nil {
			_ = fmt.Errorf("user not created: %v", users)
		}

		_, err := r.Db.
			NewUpdate().
			Model(&users).
			Returning("*").
			Exec(ctx)
		if err != nil {
			return nil, err
		}

		log.Println("user created")

		users = append(users, user...)
		if users != nil {
			return nil, err
		}
	}
	return users, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context,
	userDelete []string) ([]string, error) {
	db := r.Db.
		NewDelete().
		Model(&model.User{}).
		Where("id IN (?)", userDelete)

	_, err := db.Exec(ctx)
	if err != nil {
		return nil, err
	}

	return userDelete, nil
}

// Validate is the resolver for the validate field.
func (r *mutationResolver) Validate(ctx context.Context) (*model.User, error) {
	user := model.User{}

	sessionKey := authpayload.
		ForContext(ctx).AuthInfo.Token
	if sessionKey == "" {
		return nil, errors.New("access is denied")
	}

	session, found := r.Sessions.
		GetSession(sessionKey)
	if !found {
		return nil, errors.New("no session for key")
	}

	if err := session.PrivateKey.Validate(); err != nil {
		return nil, err
	}

	Id := strconv.Itoa(len(session.Id))

	user = model.User{
		ID:   Id,
		Role: model.Roles(model.RolesUser),
	}

	return &user, nil
}

// Me "Me" is the resolver for the "me" field.
func (r *queryResolver) Me(ctx context.Context, login string) (*model.User, error) {
	user := model.User{}

	bunIn := bun.In(login)
	scanDb := r.Db.
		NewSelect().
		Model(&user).
		Where("login = ?",
			bunIn).
		Scan(ctx)
	if scanDb != nil {
		return nil, scanDb
	}

	log.Printf("user found: %v\n", user)

	return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// AuthenticatedQuery is the resolver for the authenticatedQuery field.
func (r *queryResolver) AuthenticatedQuery(ctx context.Context) (*model.SomeType, error) {
	panic(fmt.Errorf("not implemented: AuthenticatedQuery - authenticatedQuery"))
}

// UserQuery is the resolver for the userQuery field.
func (r *queryResolver) UserQuery(ctx context.Context, id string) (*model.SomeType, error) {
	panic(fmt.Errorf("not implemented: UserQuery - userQuery"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
