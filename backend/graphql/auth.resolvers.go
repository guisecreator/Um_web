package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.34

import (
	"context"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/guisecreator/um_web/graphql/model"
	"github.com/guisecreator/um_web/pkg/authpayload"
	"github.com/guisecreator/um_web/pkg/sessions"
	"github.com/guisecreator/um_web/pkg/token"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, login string, email string, password string) (*model.AuthPayload, error) {
	panic(fmt.Errorf("not implemented: Signup - signup"))
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, login string, email string, password string) (*model.AuthPayload, error) {
	user := model.User{}

	errScan := r.Db.NewSelect().Model(&user).Scan(ctx)
	if errScan != nil {
		return nil, errScan
	}

	createAt := time.Now().Format(time.RFC3339)
	updateAt := time.Now().Format(time.RFC3339)

	tokenGen, err := token.GenerateToken(user.ID)
	if err != nil {
		return nil, fmt.Errorf("generateToken gen error: %v", err)
	}

	newToken, err := tokenGen.PutTokenInJSON()
	if err != nil {
		return nil, err
	}

	r.Sessions.AddSession(newToken, sessions.Session{
		Id:         user.ID,
		Login:      model.User{Login: login},
		PrivateKey: tokenGen.PrivateKey,
		Roles:      model.Roles(model.RolesUser),
	})

	expired := time.Now().AddDate(1, 0, 0)
	cookie := http.Cookie{
		Name:     authpayload.CookieName,
		Value:    newToken,
		Path:     "/",
		Expires:  expired,
		MaxAge:   3600,
		Secure:   true,
		HttpOnly: false,
	}

	payload := authpayload.ForContext(ctx)
	http.SetCookie(payload.ResponseWriter, &cookie)

	Id := strconv.Itoa(len(user.ID))

	user = model.User{
		Login:    login,
		Email:    email,
		Password: password,
		ID:       Id,
		Role:     model.Roles(model.RolesUser),
		CreateAt: createAt,
		UpdateAt: updateAt,
	}

	authInfo := &model.AuthInfo{Token: newToken}
	authPayLoad := &model.AuthPayload{
		User: &user,
		Info: authInfo,
	}

	return authPayLoad, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, login string) (*string, error) {
	user := model.User{}

	db := r.Db.NewSelect().Model(&user).Scan(ctx)
	if db != nil {
		return nil, db
	}

	tokenFromContext, err := authpayload.
		GetSessionTokenFromContext(ctx)
	if err != nil {
		return nil, err
	}

	r.Sessions.RemoveSession(tokenFromContext)

	user = model.User{
		Login: login,
	}

	return &tokenFromContext, nil
}
